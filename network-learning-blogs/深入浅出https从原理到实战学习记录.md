# 密码学
## 1.基本认知
每个密码学算法只能解决**特定**的问题，实际应用的时候可能会有很多陷阱，也就是说要注意每个密码学算法的**限度**
### 1.1四个目标
+ 机密性  
+ 完整性
+ 身份验证
+ 不可抵赖性
### 1.2 加密基元
一般将**随机数**和**hash算法**作为其他密码学算法的加密基元（Cryptographic Primitives）
### 1.2.1 hash算法的特性
#### 1. 文件比较  
   无论文件多大，摘要值的计算非常快速；即使文件内容99%相同，对应摘要值也不同
#### 2. 身份校验  
   存储口令（password or passphrase）的摘要值而不是原始值，这样即使口令数据库泄露，通过摘要值是很难逆向推导出原始数值的，攻击者很难进行伪造用户攻击，但是仍然存在一定安全风险
#### 3. 强抗碰撞性  
   两个不同的值能得到同样的摘要值，表示产生了hash碰撞，这样就不具备强抗碰撞性
#### 4. 弱抗碰撞性
   给定一个消息和这个消息对应的摘要值，很难找到一条不同的消息也具有相同的摘要值。如果某个算法不符合该特性，表示遇到了second-preimage攻击。

   强抗碰撞性和弱抗碰撞性是相对的概念，并不代表算法的安全程度。在密码学中，选用的hash算法至少也要具备弱抗碰撞性，具备弱抗碰撞性的算法必然也具备强抗碰撞性。
#### 5. 单向性
   给定一个摘要值很难找出它的原始消息。
### 1.2.2 密码学hash算法的分类
1. MD5
    摘要值长度固定味128bit，但是目前已经被证明为不安全了，违反强抗碰撞性原则，但还没有破坏单一性原则
2. SHA  
    SHA（Secure Hash Algorithm） 不是一个算法，是一组算法，主要分为三类，-1-2-3.
### 1.2.3对称加密算法（Symmetric-key Algorithm）
密码学中用于数据加密的算法主要两种，对称加密算法以及非对称加密算法。两种算法主要都是用来保证数据的机密性。

对称加密算法主要是通过一个算法和一个密钥（secret key）对明文进行处理（加密，解密），一般来说，密钥的长度决定了算法的安全性。

对称加密算法中最常见的也是标准算法，**AES算法**

### 1.2.4消息验证码
消息验证码（Message Authentication Code，MAC）算法，用于保证消息完整，不被篡改。很多情况下，传递的消息并没有必要加密，只需要确保消息完整且没有被篡改即可。Hash算法并不能保证消息没有被篡改，假如攻击者将消息截获，同时修改摘要值，那么接收方无法确保消息有无被篡改，摘要值和原文比对仍然是正确的。

### 1.2.5 公开密钥算法
Public Key Cryptography，也被称为非对称加密算法。公开密钥算法不是一个算法，而是一组算法。  
与对称加密算法的**异同**：
1. **功能不一样**  
对称加密算法主要用于加密解密，公开密钥算法功能较多，除了加密解密，还能进行密钥协商，**数字签名**。
2. **密钥是一对**  
   对称加密算法中，加密解密用的是同一个密钥。公开密钥算法中，密钥分为**公钥**（public key）和**私钥**（private key），一般私钥由密钥对的生成方（比如服务器端）持有，而公钥可以任何人都持有，不怕泄露。
3. **运算速度慢**  
   相比于对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下需要加密的明文数据都非常大，如果全都用公开密钥算法，性能会比较差。公开密钥算法一般来说用于密钥协商和数字签名，这两种运算的数据相对较小。
## TLS
  TLS（Transport Layer Security）协议。是ssl协议（Secure Sockets Layer）的升级版，现在一般称呼为TLS/SSL协议。  
  TLS/SSL协议是**最常见**的安全解决方案，但**并不是唯一**的解决方案，选择的时候需要认识到TLS/SSl的优缺点。
### TLS/SSL协议的目标
TLS/SSL协议位于应用层协议（例如http）和TCP之间，一般都构建在TCP之上，也可以构建在UDP上，但是用的比较少，被称为DTLS（Datagram Transport Layer Security）协议。

TLS/SSL协议有四个目标：
+ **数据是机密的**：通信两端传输的数据应该是安全的，不可伪造和篡改。
+ **互操作性**：协议是标准的，任何开发者基于TLS/SSL RFC设计规范都可以实现该协议，同时开发者也很容易在应用中引入TLS/SSL协议。
+ **可扩展性**：可以动态的引入新的算法，因为密码学算法是不断迭代的，随着时间的推移，会出现更安全的算法。协议允许通信双方协商出都支持的密码学算法，考虑到双方环境可能不一样。
+ **效率**：解决方案必须是高效的，因为TLS/SSL协议涉及很多密码学算法的运算，增加了通信延时和机器负载。
### Https和TLS/SSL的关系
实际上HTTP + TLS/SSL就是HTTPS，就是说HTTPS拥有HTTP所有的特征，并且http消息由TLS/SSL协议进行安全保护。
### TLS/SSL协议背后的算法
核心就三大步骤：**认证**，**密钥协商**，**数据加密**。以及很多细节。
#### 密钥协商
不论用哪种密钥协商算法，客户端和服务器最红会协商出**预备主密钥**，然后转换为主密钥，最终再转换味密钥块。

预备主密钥有几个特点：
+ 每个客户端和服务器端初始化连接的时候生成的预备主密钥，**每次都是不一样的**
+ 预备主密钥再会话结束后（连接关闭后）会**自动释放**。
+ 必须保证是机密的，确保攻击者无法解密出来，也无法猜测。

在https种，一般采用**rsa**或者**dh**算法协商预备主密钥。其中dh算法的最大优点在于预备主密钥是由客户端和服务端共同计算出来的，只有经过消息互换才能计算出预备主密钥。
#### 前向安全性
 Perfect Forward Secrecy。rsa和dh密钥协商算法都不能确保前向安全性。

 rsa密钥协商算法关键在于服务器的私钥。在没有服务器私钥前，攻击者虽然不能破解信息，但是可以**截获之前所有的通信数据**，一段时间后，私钥由于若干原因泄露，虽然服务器管理员可以立刻生成新的密钥对，但是攻击者可以通过**泄露的之前的私钥**，去**解析之前截获的消息**，造成数据泄露。**导致所有的历史通信被解密**。

 静态dh算法也类似，动态dh算法来说，相对较为安全，即使在某次连接中泄露，也仅会导致本次连接中的加密数据被破解。
 #### 中间人攻击
 虽然上之前的方案看起来无懈可击，但是不能避免**中间人攻击**。也就是说在协商过程中，客户端和服务器端中间存在攻击者，直接劫持客户端的请求并伪造给服务端，这样的结果相当于所有信息对于中间人来说都是透明的。

 公开密钥算法中，所有的网络通信都会存在中间人攻击。在https协议中必须引入**PKI**技术解决**身份验证**问题，PKI技术的核心就是**证书**。
 #### PKI
 PKI并不是TLS/SSL协议的一部分，但是在https必须引入PKI技术才能保证安全。简单来说，PKI技术能保证客户端接受到的服务器公钥确实是真实服务器的公钥，而不是中间人伪造的。

 主要是通过CA机构，相当于身份证，浏览器绝对信任CA发布的证书。
